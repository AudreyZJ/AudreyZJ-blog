---
layout: post
title: Guice - AOP  (Aspect Oriented Programming)
date: '2011-09-30T18:05:00.000-07:00'
author: Babji Prashanth, Chetty
categories:
- java
tags:
- google guice
- dependency injection with AOP
- prashanth
- chetty
- guice
- aopalliance
- babji
- check
- guice AOP
- java
- licence
modified_time: '2011-09-30T18:24:11.139-07:00'
blogger_id: tag:blogger.com,1999:blog-290045043624227719.post-3546838259281349657
blogger_orig_url: http://java-bytes.blogspot.com/2011/09/guice-aop-aspect-oriented-programming.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">Aspect Oriend Programming (AOP) is a programming methodology or perspective, which was conceived to bring in more modular approach to the already existing 'Object Oriented Methodology'. Dependency Injection, which is another programming methodology to bring in more modular approach or to create loosely coupled modules, which compliments AOP. In this post, I'm going to write something about how the DI framework 'Guice' uses it's DI mechanism, to provide AOP concepts (method interceptors).<br /><br />Lets think of a small application, where users need to purchase a licence or have some special privileges to use some functionality of the application. Below is the code for this app, which provides the main functionality of this app (Service.java interface and it's implementation - ServiceImpl.java):<br /><br /></div> <b>Service.java</b> <pre class="brush:java"><br />package com.chetty.licence;<br /><br />/**<br /> * Service Interface<br /> *<br /> * @author Babji, Chetty<br /> */<br />public interface Service {<br />    public void doSomething1();<br />    public void doSomething2();<br />}<br /></pre><br /><b>ServiceImpl.java</b><br /><pre class="brush:java"><br />package com.chetty.licence;<br /><br />/**<br /> * Service Implementation.<br /> * <br /> * @author Babji, Chetty<br /> */<br />public class ServiceImpl implements Service {    <br />    public void doSomething1() {<br />        System.out.println("I'm doing something - 1");<br />    }<br /><br />    @LicenceRequired<br />    public void doSomething2() {<br />        System.out.println("I'm doing something - 2");<br />    }<br />}<br /></pre><br />As you see in the above Service interface implementation, there is a annotation called "LicenceRequired" for the second method. What we are trying to do is to provide limited access to the functionality of this app or that method, by keeping a check (by intercepting) on that method, whenever it is called. The code for the "LicenceRequired" annotation is as below: <br /><br /><b>LicenceRequired.java</b><br /><pre class="brush:java"><br />package com.chetty.licence;<br /><br />import java.lang.annotation.ElementType;<br />import java.lang.annotation.Retention;<br />import java.lang.annotation.RetentionPolicy;<br />import java.lang.annotation.Target;<br /><br /><br />/**<br /> *<br /> * @author Babji, Chetty.<br /> */<br />@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD)<br />public @interface LicenceRequired {}<br /></pre><br />Guice provides the "method interceptors" functionality by using "AOP Alliance" (aopalliance.jar) as it's external library. The annotation "LicenceRequired" is used as a marker (See  ServiceImpl.java's doSomething2() method) to intercept the required method. Guice knows that this method has to be intercepted, by the following configuration (Guice Module): <br /><br /><b>LicenceModule.java</b><br /><pre class="brush:java"><br />package com.chetty.licence.guice.module;<br /><br />import com.chetty.licence.LicenceRequired;<br />import com.chetty.licence.LicenceChecker;<br />import com.chetty.licence.Service;<br />import com.chetty.licence.ServiceImpl;<br />import com.google.inject.AbstractModule;<br />import com.google.inject.matcher.Matchers;<br /><br /><br />/**<br /> *<br /> * @author b.chetty<br /> */<br />public class LicenceModule extends AbstractModule {<br />    protected void configure() {<br />        LicenceChecker licenceChecker = new LicenceChecker();<br />        requestInjection(licenceChecker);<br />        bindInterceptor(Matchers.any(), Matchers.annotatedWith(LicenceRequired.class), licenceChecker);<br /><br />        bind(Service.class).to(ServiceImpl.class);<br />    }<br />}<br /></pre><br />The service client or adapter, is as follows: <br /><br /><b>ServiceAdapter.java</b><br /><pre class="brush:java"><br />package com.chetty.licence;<br /><br />import com.google.inject.Inject;<br /><br />/**<br /> * Service Adapter.<br /> * <br /> * @author Babji, Chetty<br /> */<br />public class ServiceAdapter {<br />    private final Service service;<br /><br />    @Inject<br />    public ServiceAdapter(Service service) {<br />        this.service = service;<br />    }<br /><br />    public void doSomething() {<br />        service.doSomething1();<br />        service.doSomething2();<br />    }<br />}<br /></pre><br />And the Licence checking functionality is done in the following class (Licence.java): <br /><br /><b>Licence.java</b><br /><pre class="brush:java"><br />package com.chetty.licence;<br /><br />/**<br /> *<br /> * @author Babji, Chetty<br /> */<br />public class Licence {<br />    public boolean checkLicence(String licenceString) {<br />        String licenceStringFromDB = getLicenceStringFromDB();<br />        return (licenceString != null && licenceStringFromDB != null && licenceString.equals(licenceStringFromDB) ? true : false);<br />    }<br /><br />    private String getLicenceStringFromDB() {<br />        return "TEST";<br />    }<br />}<br /></pre><br />And below is the class, that aids the method intercepting process. If you check the Guice Configuration module (LicenceModule.java), I have configured the "LicenceRequired" annotation, to work with "LicenceChecker" class, so that when the method with business logic, annotated with "LicenceRequired" is called, control is passed over to the "LicenceChecker" class. <br /><br /><b>LicenceChecker.java</b><br /><pre class="brush:java"><br />package com.chetty.licence;<br /><br />import com.google.inject.Inject;<br />import java.util.Scanner;<br />import org.aopalliance.intercept.MethodInterceptor;<br />import org.aopalliance.intercept.MethodInvocation;<br /><br />/**<br /> *<br /> * @author Babji, Chetty<br /> */<br />public class LicenceChecker implements MethodInterceptor {<br />    @Inject<br />    private Licence licence;<br /><br />    @Override<br />    public Object invoke(MethodInvocation invocation) throws Throwable {<br />        //Get License String from the user. You can read the licence string from a licence-file, from connsole, etc options.<br />        //In this case, I'm just reading it from the console.<br />        System.out.println("You need a valid Licence to use this functionality...Please enter your Licence string: ");<br />        Scanner input = new Scanner(System.in);<br />        String licenceString = input.nextLine();<br />                                <br />        if(!licence.checkLicence(licenceString)) {<br />            //Here, you can either throw an exception and show a "Invalid Licence" message or customize it according to your needs.            <br />            System.out.println("Invalid Licence!");<br />            throw new IllegalStateException("Invalid Licence : " + invocation.getMethod().getName());<br />        }<br />        <br />        return invocation.proceed();<br />    }<br />}<br /></pre><br />And, below is the main class (entry point) for this application called "licenceCheck": <br /><br /><b>LicenceApp.java</b><br /><pre class="brush:java"><br />package com.chetty.licence;<br /><br />import com.chetty.licence.guice.module.LicenceModule;<br />import com.google.inject.Guice;<br />import com.google.inject.Injector;<br /><br />/**<br /> * @author Babji, Chetty<br /> */<br />public class LicenceApp {<br />    public static void main(String[] args) {        <br />        Injector injector = Guice.createInjector(new LicenceModule());<br />        ServiceAdapter serviceInterface = injector.getInstance(ServiceAdapter.class);<br />        serviceInterface.doSomething();<br />    }<br />}<br /></pre><br /><br />This app uses a hardcoded "TEST" string as licence string. This is checked with the user input licence string and if they don't match, the method with "LicenceRequired" annotation will not be executed. If you execute the application with a test string "TEST1234", "I'm doing something - 1" is printed, followed by "Invalid Licence!" and an IllegalStateExcception (implying that the second method - doSomething2() is not executed). If the user input licence string is "TEST", both the methods are executed. This idea can be customized and implemented in your own projects. There are also other uses of this AOP in handling transactions, logging, security, etc. <br /><br />You can get the source code for this app, on Google's code repository: <a href="http://code.google.com/p/licence-check/source/browse/">licenceCheck</a><br /><br /><b>Disclaimer</b>: This sample project was created for fun and to learn new techniques. Use the code, at your own risk! :P
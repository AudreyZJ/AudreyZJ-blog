---
layout: post
title: Google Guice - Example
date: '2010-02-20T17:03:00.000-08:00'
author: Babji Prashanth, Chetty
categories:
- java
tags:
- babji chetty
- google guice
- chetty prashanth
- guice sample tutorial
- guice example
- java dependency injection framework
- guice injector
modified_time: '2011-02-24T11:50:05.134-08:00'
blogger_id: tag:blogger.com,1999:blog-290045043624227719.post-5843212091642329877
blogger_orig_url: http://java-bytes.blogspot.com/2010/02/google-guice-example.html
---

<a href="http://martinfowler.com/articles/injection.html">Dependency Injection</a> and <a href="http://code.google.com/p/google-guice/">Google's Guice framework</a> need no introduction from me, as the documentation on Google's project hosting site is pretty good. Also, there are loads of articles and other information related to these topics, on the internet. So, I will start off with a pretty basic java project, to show 'Guice' in action. <br /><br />Okay...Now lets think of a very small framework/project (so that, it will be easy to understand) to calculate the sum of all consecutive integers from 1 to n. You are given 'n' as the input and you are supposed to output the sum of all consecutive integers from 1 to n. Lets imagine that there is only one implementation, that we know of (at that moment), to implement the solution...but lets stick to a good design procedure of object oriented languages and make it flexible for future changes.<br /><br />Below is the code for the only implementation that I know of, at that moment:<br /><br />IMathAdditionService:<br /><br /><pre class="brush:java">package com.chetty.service;<br /><br />public interface IMathAdditionService {<br />public int sumOfAllConsecutiveNumbers(int n);<br />}<br /><br /></pre><br /><br />SnailAdditionService (implements IMathAdditionService):<br /><br /><pre class="brush:java">package com.chetty.service;<br /><br />public class SnailAdditionService implements IMathAdditionService {<br />@Override<br />public int sumOfAllConsecutiveNumbers(int n) {  <br />int sum = 0;<br />long startTime = System.nanoTime();<br /><br />for(int i=1;i<=n;i++) {<br />sum += i;<br />}<br /><br />long endTime = System.nanoTime();<br /><br />System.out.println("Snail Addition Service - Sum : " + sum);<br />System.out.println("Time Complexity - O(n) and Time Taken : " + (endTime - startTime));<br />return sum;<br />}<br />}<br /></pre>  Okay, now lets create an interface/client for this service (NOTE: I assume, you know something about 'Factory Pattern'. If not, check it <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">here</a>!). If you implement the 'Factory Pattern', this is how the code looks like:  MathServiceFactory:  <pre class="brush:java">package com.chetty.service;<br /><br />public class MathServiceFactory {<br />private MathServiceFactory() {}<br />private static IMathAdditionService mathService = new SnailAdditionService();<br /><br />public static IMathAdditionService getInstance() {<br />return mathService;<br />}<br /><br />public static void setInstance(IMathAdditionService service) {<br />mathService = service;<br />}<br />}<br /><br /></pre> MathClient:  <pre class="brush:java">package com.chetty.client;<br /><br />import com.chetty.service.IMathAdditionService;<br />import com.chetty.service.MathServiceFactory;<br /><br />public class MathClient {<br />public void go() {<br />IMathAdditionService mathService = MathServiceFactory.getInstance();<br />mathService.sumOfAllConsecutiveNumbers(1000);<br />}<br />}<br /></pre> Implementing the factory pattern makes it a bit loosely coupled, but doesn't really take off the dependencies. Also, you would have to provide different factories for new/different implementations. This is where 'Dependency Injection' comes in handy and Google's Guice is one of the frameworks created to provide DI techniques. Below is the code, which uses 'Constructor Injection' and the Guice's 'Inject' annotation, to inject the required service, at runtime. This kind of approach is more flexible, has less code and you can bind/implement new services (or service providers) just by a minimal change in code/configuration. For the same reason, it is also easier to test the code. 'Plug n Play', 'Service Oriented Arhcitecture (SOA)', 'Webservices' come to mind, when you think about this kind of loosely coupled stuff. Below is the implementation of the client using Guice:  <pre class="brush:java">package com.chetty.client;<br /><br />import com.chetty.service.IMathAdditionService;<br />import com.google.inject.Inject;<br /><br />public class MathClient {<br />private final IMathAdditionService mathService;<br /><br />@Inject<br />public MathClient(IMathAdditionService mathService) {<br />this.mathService = mathService;<br />}<br /><br />public int sumOfAllConsecutiveNumbers(int n) {<br />return mathService.sumOfAllConsecutiveNumbers(n);<br />}<br />}<br /><br /></pre> Apart from this, you would have to create a module (which provides/replaces the factory class implementation):  MathModule:  <pre class="brush:java">package com.chetty.module;<br /><br />import com.chetty.service.IMathAdditionService;<br />import com.chetty.service.SnailAdditionService;<br />import com.google.inject.AbstractModule;<br /><br />public class MathModule extends AbstractModule {<br />@Override<br />protected void configure() {<br />bind(IMathAdditionService.class).to(SnailAdditionService.class);<br />}<br />}<br /><br /></pre> As you see in the code above, this is the class where the required service is configured for use, by the client. In the future, if you have a new implementation for the client, all you have to do is to change the configuration. This technique sticks better to the '<a href="http://en.wikipedia.org/wiki/Open/closed_principle">Open Closed Principle</a>', than the factory implementation.  And below is the main class, where you use the Guice's injector:  <pre class="brush:java">package com.chetty.client;<br /><br />import com.chetty.module.MathModule;<br />import com.chetty.service.IMathAdditionService;<br />import com.google.inject.Guice;<br />import com.google.inject.Injector;<br /><br />public class MathApp {<br />public static void main(String[] args) {<br />Injector injector = Guice.createInjector(new MathModule());<br /><br />MathClient mathClient = injector.getInstance(MathClient .class);<br /><br />mathClient.sumOfAllConsecutiveNumbers(1000);<br />}<br />}<br /></pre> Ok...At some point later, I got to know a new algorithm/technique to find the sum of all consecutive integers from 1 to n. So, I want to hook up this new solution to the client, which is faster and has less code. Below is the code for that:  FastAdditionService:  <pre class="brush:java">package com.chetty.service;<br /><br />public class FastAdditionService implements IMathAdditionService {<br />@Override<br />public int sumOfAllConsecutiveNumbers(int n) {<br />long startTime = System.nanoTime();<br />int sum = (n * (n+1))/2;<br />long endTime = System.nanoTime();<br /><br />System.out.println("Fast Addition Service - Sum : " + sum);<br />System.out.println("Time Complexity - O(1) and Time Taken : " + (endTime - startTime));<br />return sum;<br />}<br />}<br /></pre> All that you have to do now, is to extend the framework (but no modifications) with this new service and change the configuration in the module class (MathModule.java), as below:  <pre class="brush:java">bind(IMathAdditionService.class).to(FastAdditionService.class);<br /></pre><br /><br />Looking at the Module class used for configuration, you might be wondering why we are providing configuration in a Java class, instead of the usual way of using XML or bundles/properties files.....Well, it has a reason...The reason is to provide a tight binding (for configuration) and catch all errors at compile time, so that there will be no untoward exceptions/errors on production, at runtime.
---
layout: post
title: Hashcode Of A String In Java
date: '2009-10-05T12:25:00.000-07:00'
author: Babji Prashanth, Chetty
categories:
- java
tags:
- babji chetty
- chetty prashanth
- unhashing a string from hashcode
- java hashcode
- why is 31 used for hashcode
- hash collisions
- hashcode and bit shifting
modified_time: '2011-03-17T14:33:26.029-07:00'
blogger_id: tag:blogger.com,1999:blog-290045043624227719.post-3334104393378501711
blogger_orig_url: http://java-bytes.blogspot.com/2009/10/hashcode-of-string-in-java.html
---

Many of the Java programmers know what 'Hashcode' means, but don't really know how exactly it is calculated and why 31 is used to calculate the hashcode. Below is the code snippet from Java 1.6, which calculates the hashcode for a string:<br /><br /><pre class="brush:java">public int hashCode() {<br />int h = hash;<br />if (h == 0) {<br />int off = offset;<br />char val[] = value;<br />int len = count;<br /><br />for (int i = 0; i < len; i++) {<br />h = 31*h + val[off++];<br />}<br />hash = h;<br />}<br /><br />return h;<br />}<br /></pre>Even if someone knows why 31 is used, there is a lot of stuff to know about 'Hashing', 'Hash Collisions' and multiple algorithms related to calculating hash values. First off, its a known fact that there is no perfect hashing algorithm, for which there are no collisions. But there are several algorithms, which minimize the collisions and are good enough to use.  Now, coming to why 31 is used in calculating hashcode, this is the reason given by Joshua Bloch, in the book 'Effective Java': <font color="green"><blockquote>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: 31 * i == (i << 5) - i. Modern VMs do this sort of optimization automatically.</blockquote></font>This wasn't sufficient for me, to understand why 31 is used. I did a bit of research and found some good links, providing some info about why 31 is used. Here are some links with very good info:  <a href="http://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier">Stack Overflow - Why does java hashcode use 31 as a multiplier</a> Apart from the above link, there are a couple of other links with pretty good info about hashing, hash collisions and performance of hashing algorithms:  <a href="http://stackoverflow.com/questions/785091/consistency-of-hashcode-on-a-java-string">Consistency Of Hashcode On A Java String</a> <a href="http://stackoverflow.com/questions/251346/best-hashing-algorithm-in-terms-of-hash-collisions-and-performance">Best Hashing Algos, In Terms Of Collisions and Performance</a> <a href="http://stackoverflow.com/questions/744735/java-array-hashcode-implementation">Java Array Hashcode Implementation</a>  <br/><br/>After reading up a bit, I wrote a sample test Java program, to find the hashcode of a string by multiplying by 31 (which is the same as shifting left (bitwise) by 5 times and subtracting, as in (i << 5) - i). Below is the sample test program:  <pre class="brush:java"><br />public class TestHash {<br />public static void main(String[] args) {<br />String str1 = &quot;What the heck?&quot;;<br /><br />int hashcode1 = 0;<br />int hashcode2 = 0;<br /><br />for(int i=0;i&lt;str1.length();i++) {<br />hashcode1 = 31*hashcode1 + str1.charAt(i);<br />hashcode2 = (hashcode2 &lt;&lt; 5) - hashcode2 + str1.charAt(i);<br />}<br /><br />System.out.println(&quot;Hashcode1 : &quot; + hashcode1);<br />System.out.println(&quot;Hashcode2 : &quot; + hashcode2);<br />}<br />}<br /></pre><br /><br />The output for this program is:<br /><br /><span style="font-weight:bold;">Hashcode1 : 277800975<br />Hashcode2 : 277800975</span><br /><br />Apart from the above info, I want to share some info from the recent article on java.sun.com, written by Joseph Darcy. It was an interesting case of <a href="http://blogs.sun.com/darcy/entry/string_unhashing?intcmp=2223">'Unhashing' - Reverse Engineering Hashcode, To Find A String That Collides With The Actual String</a>. This was an interesting way of finding 'Hash Collisions'. I then tested the code from Joseph Darcy, by writing a sample program, as below:<br /><br /><pre class="brush:java">public class TestHash {<br />/**<br />* @author - Babji P, Chetty<br />*/<br />public static void main(String[] args) {<br />String str1 = &quot;what the heck?&quot;;<br /><br />int hashcode1 = 0;<br />int hashcode2 = 0;<br /><br />for(int i=0;i&lt;str1.length();i++) {<br />hashcode1 = 31*hashcode1 + str1.charAt(i);<br />hashcode2 = (hashcode2 &lt;&lt; 5) - hashcode2 + str1.charAt(i);<br />}<br /><br />System.out.println(&quot;Hashcode1 : &quot; + hashcode1);<br />System.out.println(&quot;Hashcode2 : &quot; + hashcode2);<br /><br />String str2 = unhash(hashcode1);<br />System.out.println(&quot;Unhashed String From Hashcode : &quot; + str2);<br /><br />int hashcode3 = 0;<br />int hashcode4 = 0;<br /><br />for(int i=0;i&lt;str2.length();i++) {<br />hashcode3 = 31*hashcode3 + str2.charAt(i);<br />hashcode4 = (hashcode4 &lt;&lt; 5) - hashcode4 + str2.charAt(i);<br />}<br /><br />System.out.println(&quot;Hashcode3 : &quot; + hashcode3);<br />System.out.println(&quot;Hashcode4 : &quot; + hashcode4);<br /><br />}<br /><br />/**<br />* Returns a string with a hash equal to the argument.<br />* @return string with a hash equal to the argument.<br />* @author - Joseph Darcy<br />*/<br />public static String unhash(int target) {<br />StringBuilder answer = new StringBuilder();<br />if (target &lt; 0) {<br />// String with hash of Integer.MIN_VALUE, 0x80000000<br />answer.append(&quot;\u0915\u0009\u001e\u000c\u0002&quot;);<br /><br />if (target == Integer.MIN_VALUE)<br />return answer.toString();<br />// Find target without sign bit set<br />target = target &amp; Integer.MAX_VALUE;<br />}<br /><br />unhash0(answer, target);<br />return answer.toString();<br />}<br /><br />/**<br />* <br />* @author - Joseph Darcy<br />*/<br />private static void unhash0(StringBuilder partial, int target) {<br />int div = target / 31;<br />int rem = target % 31;<br /><br />if (div &lt;= Character.MAX_VALUE) {<br />if (div != 0)<br />partial.append((char)div);<br />partial.append((char)rem);<br />} else {<br />unhash0(partial, div);<br />partial.append((char)rem);<br />}<br />}<br />}<br /><br /></pre><br /><br />The output for the above program is:<br /><br /><span style="font-weight:bold;">Hashcode1 : 1279794159<br />Hashcode2 : 1279794159<br />Unhashed String From Hashcode : ?☻§◄<br />Hashcode3 : 1279794159<br />Hashcode4 : 1279794159</span><br /><br />So the strings "what the heck?" and "?☻§◄" have the same hashcode. <span style="font-weight:bold;">What the heck?!?!</span>